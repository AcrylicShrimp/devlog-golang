// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"devlog/ent/admin"
	"devlog/ent/adminsession"
	"devlog/ent/category"
	"devlog/ent/post"
	"devlog/ent/postattachment"
	"devlog/ent/postimage"
	"devlog/ent/postthumbnail"
	"devlog/ent/postvideo"
	"devlog/ent/predicate"
	"fmt"
	"sync"
	"time"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin          = "Admin"
	TypeAdminSession   = "AdminSession"
	TypeCategory       = "Category"
	TypePost           = "Post"
	TypePostAttachment = "PostAttachment"
	TypePostImage      = "PostImage"
	TypePostThumbnail  = "PostThumbnail"
	TypePostVideo      = "PostVideo"
)

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op              Op
	typ             string
	id              *int
	email           *string
	username        *string
	password        *string
	joined_at       *time.Time
	clearedFields   map[string]struct{}
	sessions        map[int]struct{}
	removedsessions map[int]struct{}
	clearedsessions bool
	posts           map[int]struct{}
	removedposts    map[int]struct{}
	clearedposts    bool
	done            bool
	oldValue        func(context.Context) (*Admin, error)
	predicates      []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *AdminMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AdminMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AdminMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *AdminMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *AdminMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *AdminMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// AddSessionIDs adds the "sessions" edge to the AdminSession entity by ids.
func (m *AdminMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the AdminSession entity.
func (m *AdminMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared returns if the "sessions" edge to the AdminSession entity was cleared.
func (m *AdminMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the AdminSession entity by IDs.
func (m *AdminMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the AdminSession entity.
func (m *AdminMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *AdminMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *AdminMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *AdminMutation) AddPostIDs(ids ...int) {
	if m.posts == nil {
		m.posts = make(map[int]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *AdminMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared returns if the "posts" edge to the Post entity was cleared.
func (m *AdminMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *AdminMutation) RemovePostIDs(ids ...int) {
	if m.removedposts == nil {
		m.removedposts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *AdminMutation) RemovedPostsIDs() (ids []int) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *AdminMutation) PostsIDs() (ids []int) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *AdminMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.email != nil {
		fields = append(fields, admin.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	if m.joined_at != nil {
		fields = append(fields, admin.FieldJoinedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldEmail:
		return m.Email()
	case admin.FieldUsername:
		return m.Username()
	case admin.FieldPassword:
		return m.Password()
	case admin.FieldJoinedAt:
		return m.JoinedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldEmail:
		return m.OldEmail(ctx)
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	case admin.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case admin.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldEmail:
		m.ResetEmail()
		return nil
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	case admin.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sessions != nil {
		edges = append(edges, admin.EdgeSessions)
	}
	if m.posts != nil {
		edges = append(edges, admin.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsessions != nil {
		edges = append(edges, admin.EdgeSessions)
	}
	if m.removedposts != nil {
		edges = append(edges, admin.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsessions {
		edges = append(edges, admin.EdgeSessions)
	}
	if m.clearedposts {
		edges = append(edges, admin.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeSessions:
		return m.clearedsessions
	case admin.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeSessions:
		m.ResetSessions()
		return nil
	case admin.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AdminSessionMutation represents an operation that mutates the AdminSession nodes in the graph.
type AdminSessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	token         *string
	used_at       *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*AdminSession, error)
	predicates    []predicate.AdminSession
}

var _ ent.Mutation = (*AdminSessionMutation)(nil)

// adminsessionOption allows management of the mutation configuration using functional options.
type adminsessionOption func(*AdminSessionMutation)

// newAdminSessionMutation creates new mutation for the AdminSession entity.
func newAdminSessionMutation(c config, op Op, opts ...adminsessionOption) *AdminSessionMutation {
	m := &AdminSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminSessionID sets the ID field of the mutation.
func withAdminSessionID(id int) adminsessionOption {
	return func(m *AdminSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminSession
		)
		m.oldValue = func(ctx context.Context) (*AdminSession, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminSession sets the old AdminSession of the mutation.
func withAdminSession(node *AdminSession) adminsessionOption {
	return func(m *AdminSessionMutation) {
		m.oldValue = func(context.Context) (*AdminSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AdminSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetToken sets the "token" field.
func (m *AdminSessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AdminSessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AdminSession entity.
// If the AdminSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminSessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AdminSessionMutation) ResetToken() {
	m.token = nil
}

// SetUsedAt sets the "used_at" field.
func (m *AdminSessionMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *AdminSessionMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the AdminSession entity.
// If the AdminSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminSessionMutation) OldUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *AdminSessionMutation) ResetUsedAt() {
	m.used_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminSession entity.
// If the AdminSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the Admin entity by id.
func (m *AdminSessionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the Admin entity.
func (m *AdminSessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the "user" edge to the Admin entity was cleared.
func (m *AdminSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AdminSessionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AdminSessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AdminSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *AdminSessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AdminSession).
func (m *AdminSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminSessionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.token != nil {
		fields = append(fields, adminsession.FieldToken)
	}
	if m.used_at != nil {
		fields = append(fields, adminsession.FieldUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, adminsession.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminsession.FieldToken:
		return m.Token()
	case adminsession.FieldUsedAt:
		return m.UsedAt()
	case adminsession.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminsession.FieldToken:
		return m.OldToken(ctx)
	case adminsession.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case adminsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AdminSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminsession.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case adminsession.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case adminsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdminSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminSessionMutation) ResetField(name string) error {
	switch name {
	case adminsession.FieldToken:
		m.ResetToken()
		return nil
	case adminsession.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case adminsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AdminSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, adminsession.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminsession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, adminsession.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case adminsession.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminSessionMutation) ClearEdge(name string) error {
	switch name {
	case adminsession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AdminSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminSessionMutation) ResetEdge(name string) error {
	switch name {
	case adminsession.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AdminSession edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	created_at    *time.Time
	modified_at   *time.Time
	clearedFields map[string]struct{}
	posts         map[int]struct{}
	removedposts  map[int]struct{}
	clearedposts  bool
	done          bool
	oldValue      func(context.Context) (*Category, error)
	predicates    []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetModifiedAt sets the "modified_at" field.
func (m *CategoryMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the value of the "modified_at" field in the mutation.
func (m *CategoryMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedAt returns the old "modified_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedAt: %w", err)
	}
	return oldValue.ModifiedAt, nil
}

// ResetModifiedAt resets all changes to the "modified_at" field.
func (m *CategoryMutation) ResetModifiedAt() {
	m.modified_at = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *CategoryMutation) AddPostIDs(ids ...int) {
	if m.posts == nil {
		m.posts = make(map[int]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *CategoryMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared returns if the "posts" edge to the Post entity was cleared.
func (m *CategoryMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *CategoryMutation) RemovePostIDs(ids ...int) {
	if m.removedposts == nil {
		m.removedposts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *CategoryMutation) RemovedPostsIDs() (ids []int) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *CategoryMutation) PostsIDs() (ids []int) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *CategoryMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.modified_at != nil {
		fields = append(fields, category.FieldModifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldModifiedAt:
		return m.ModifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldModifiedAt:
		return m.OldModifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.posts != nil {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedposts != nil {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedposts {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	uuid               *string
	slug               *string
	access_level       *post.AccessLevel
	title              *string
	content            *string
	html_content       *string
	preview_content    *string
	created_at         *time.Time
	modified_at        *time.Time
	clearedFields      map[string]struct{}
	author             map[int]struct{}
	removedauthor      map[int]struct{}
	clearedauthor      bool
	category           *int
	clearedcategory    bool
	thumbnail          *int
	clearedthumbnail   bool
	images             map[int]struct{}
	removedimages      map[int]struct{}
	clearedimages      bool
	videos             map[int]struct{}
	removedvideos      map[int]struct{}
	clearedvideos      bool
	attachments        map[int]struct{}
	removedattachments map[int]struct{}
	clearedattachments bool
	done               bool
	oldValue           func(context.Context) (*Post, error)
	predicates         []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id int) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *PostMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *PostMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *PostMutation) ResetUUID() {
	m.uuid = nil
}

// SetSlug sets the "slug" field.
func (m *PostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostMutation) ResetSlug() {
	m.slug = nil
}

// SetAccessLevel sets the "access_level" field.
func (m *PostMutation) SetAccessLevel(pl post.AccessLevel) {
	m.access_level = &pl
}

// AccessLevel returns the value of the "access_level" field in the mutation.
func (m *PostMutation) AccessLevel() (r post.AccessLevel, exists bool) {
	v := m.access_level
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessLevel returns the old "access_level" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldAccessLevel(ctx context.Context) (v post.AccessLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessLevel: %w", err)
	}
	return oldValue.AccessLevel, nil
}

// ResetAccessLevel resets all changes to the "access_level" field.
func (m *PostMutation) ResetAccessLevel() {
	m.access_level = nil
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
}

// SetHTMLContent sets the "html_content" field.
func (m *PostMutation) SetHTMLContent(s string) {
	m.html_content = &s
}

// HTMLContent returns the value of the "html_content" field in the mutation.
func (m *PostMutation) HTMLContent() (r string, exists bool) {
	v := m.html_content
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLContent returns the old "html_content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldHTMLContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHTMLContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHTMLContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLContent: %w", err)
	}
	return oldValue.HTMLContent, nil
}

// ResetHTMLContent resets all changes to the "html_content" field.
func (m *PostMutation) ResetHTMLContent() {
	m.html_content = nil
}

// SetPreviewContent sets the "preview_content" field.
func (m *PostMutation) SetPreviewContent(s string) {
	m.preview_content = &s
}

// PreviewContent returns the value of the "preview_content" field in the mutation.
func (m *PostMutation) PreviewContent() (r string, exists bool) {
	v := m.preview_content
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviewContent returns the old "preview_content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPreviewContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPreviewContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPreviewContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviewContent: %w", err)
	}
	return oldValue.PreviewContent, nil
}

// ResetPreviewContent resets all changes to the "preview_content" field.
func (m *PostMutation) ResetPreviewContent() {
	m.preview_content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetModifiedAt sets the "modified_at" field.
func (m *PostMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the value of the "modified_at" field in the mutation.
func (m *PostMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedAt returns the old "modified_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedAt: %w", err)
	}
	return oldValue.ModifiedAt, nil
}

// ResetModifiedAt resets all changes to the "modified_at" field.
func (m *PostMutation) ResetModifiedAt() {
	m.modified_at = nil
}

// AddAuthorIDs adds the "author" edge to the Admin entity by ids.
func (m *PostMutation) AddAuthorIDs(ids ...int) {
	if m.author == nil {
		m.author = make(map[int]struct{})
	}
	for i := range ids {
		m.author[ids[i]] = struct{}{}
	}
}

// ClearAuthor clears the "author" edge to the Admin entity.
func (m *PostMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared returns if the "author" edge to the Admin entity was cleared.
func (m *PostMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// RemoveAuthorIDs removes the "author" edge to the Admin entity by IDs.
func (m *PostMutation) RemoveAuthorIDs(ids ...int) {
	if m.removedauthor == nil {
		m.removedauthor = make(map[int]struct{})
	}
	for i := range ids {
		m.removedauthor[ids[i]] = struct{}{}
	}
}

// RemovedAuthor returns the removed IDs of the "author" edge to the Admin entity.
func (m *PostMutation) RemovedAuthorIDs() (ids []int) {
	for id := range m.removedauthor {
		ids = append(ids, id)
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
func (m *PostMutation) AuthorIDs() (ids []int) {
	for id := range m.author {
		ids = append(ids, id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *PostMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
	m.removedauthor = nil
}

// SetCategoryID sets the "category" edge to the Category entity by id.
func (m *PostMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *PostMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared returns if the "category" edge to the Category entity was cleared.
func (m *PostMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *PostMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *PostMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *PostMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// SetThumbnailID sets the "thumbnail" edge to the PostThumbnail entity by id.
func (m *PostMutation) SetThumbnailID(id int) {
	m.thumbnail = &id
}

// ClearThumbnail clears the "thumbnail" edge to the PostThumbnail entity.
func (m *PostMutation) ClearThumbnail() {
	m.clearedthumbnail = true
}

// ThumbnailCleared returns if the "thumbnail" edge to the PostThumbnail entity was cleared.
func (m *PostMutation) ThumbnailCleared() bool {
	return m.clearedthumbnail
}

// ThumbnailID returns the "thumbnail" edge ID in the mutation.
func (m *PostMutation) ThumbnailID() (id int, exists bool) {
	if m.thumbnail != nil {
		return *m.thumbnail, true
	}
	return
}

// ThumbnailIDs returns the "thumbnail" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThumbnailID instead. It exists only for internal usage by the builders.
func (m *PostMutation) ThumbnailIDs() (ids []int) {
	if id := m.thumbnail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThumbnail resets all changes to the "thumbnail" edge.
func (m *PostMutation) ResetThumbnail() {
	m.thumbnail = nil
	m.clearedthumbnail = false
}

// AddImageIDs adds the "images" edge to the PostImage entity by ids.
func (m *PostMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the PostImage entity.
func (m *PostMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared returns if the "images" edge to the PostImage entity was cleared.
func (m *PostMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the PostImage entity by IDs.
func (m *PostMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the PostImage entity.
func (m *PostMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *PostMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *PostMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddVideoIDs adds the "videos" edge to the PostVideo entity by ids.
func (m *PostMutation) AddVideoIDs(ids ...int) {
	if m.videos == nil {
		m.videos = make(map[int]struct{})
	}
	for i := range ids {
		m.videos[ids[i]] = struct{}{}
	}
}

// ClearVideos clears the "videos" edge to the PostVideo entity.
func (m *PostMutation) ClearVideos() {
	m.clearedvideos = true
}

// VideosCleared returns if the "videos" edge to the PostVideo entity was cleared.
func (m *PostMutation) VideosCleared() bool {
	return m.clearedvideos
}

// RemoveVideoIDs removes the "videos" edge to the PostVideo entity by IDs.
func (m *PostMutation) RemoveVideoIDs(ids ...int) {
	if m.removedvideos == nil {
		m.removedvideos = make(map[int]struct{})
	}
	for i := range ids {
		m.removedvideos[ids[i]] = struct{}{}
	}
}

// RemovedVideos returns the removed IDs of the "videos" edge to the PostVideo entity.
func (m *PostMutation) RemovedVideosIDs() (ids []int) {
	for id := range m.removedvideos {
		ids = append(ids, id)
	}
	return
}

// VideosIDs returns the "videos" edge IDs in the mutation.
func (m *PostMutation) VideosIDs() (ids []int) {
	for id := range m.videos {
		ids = append(ids, id)
	}
	return
}

// ResetVideos resets all changes to the "videos" edge.
func (m *PostMutation) ResetVideos() {
	m.videos = nil
	m.clearedvideos = false
	m.removedvideos = nil
}

// AddAttachmentIDs adds the "attachments" edge to the PostAttachment entity by ids.
func (m *PostMutation) AddAttachmentIDs(ids ...int) {
	if m.attachments == nil {
		m.attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the PostAttachment entity.
func (m *PostMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared returns if the "attachments" edge to the PostAttachment entity was cleared.
func (m *PostMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the PostAttachment entity by IDs.
func (m *PostMutation) RemoveAttachmentIDs(ids ...int) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the PostAttachment entity.
func (m *PostMutation) RemovedAttachmentsIDs() (ids []int) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *PostMutation) AttachmentsIDs() (ids []int) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *PostMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, post.FieldUUID)
	}
	if m.slug != nil {
		fields = append(fields, post.FieldSlug)
	}
	if m.access_level != nil {
		fields = append(fields, post.FieldAccessLevel)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.html_content != nil {
		fields = append(fields, post.FieldHTMLContent)
	}
	if m.preview_content != nil {
		fields = append(fields, post.FieldPreviewContent)
	}
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.modified_at != nil {
		fields = append(fields, post.FieldModifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldUUID:
		return m.UUID()
	case post.FieldSlug:
		return m.Slug()
	case post.FieldAccessLevel:
		return m.AccessLevel()
	case post.FieldTitle:
		return m.Title()
	case post.FieldContent:
		return m.Content()
	case post.FieldHTMLContent:
		return m.HTMLContent()
	case post.FieldPreviewContent:
		return m.PreviewContent()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldModifiedAt:
		return m.ModifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldUUID:
		return m.OldUUID(ctx)
	case post.FieldSlug:
		return m.OldSlug(ctx)
	case post.FieldAccessLevel:
		return m.OldAccessLevel(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldHTMLContent:
		return m.OldHTMLContent(ctx)
	case post.FieldPreviewContent:
		return m.OldPreviewContent(ctx)
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldModifiedAt:
		return m.OldModifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case post.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case post.FieldAccessLevel:
		v, ok := value.(post.AccessLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessLevel(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldHTMLContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLContent(v)
		return nil
	case post.FieldPreviewContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviewContent(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldUUID:
		m.ResetUUID()
		return nil
	case post.FieldSlug:
		m.ResetSlug()
		return nil
	case post.FieldAccessLevel:
		m.ResetAccessLevel()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldHTMLContent:
		m.ResetHTMLContent()
		return nil
	case post.FieldPreviewContent:
		m.ResetPreviewContent()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.author != nil {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.category != nil {
		edges = append(edges, post.EdgeCategory)
	}
	if m.thumbnail != nil {
		edges = append(edges, post.EdgeThumbnail)
	}
	if m.images != nil {
		edges = append(edges, post.EdgeImages)
	}
	if m.videos != nil {
		edges = append(edges, post.EdgeVideos)
	}
	if m.attachments != nil {
		edges = append(edges, post.EdgeAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeAuthor:
		ids := make([]ent.Value, 0, len(m.author))
		for id := range m.author {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeThumbnail:
		if id := m.thumbnail; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeVideos:
		ids := make([]ent.Value, 0, len(m.videos))
		for id := range m.videos {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedauthor != nil {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.removedimages != nil {
		edges = append(edges, post.EdgeImages)
	}
	if m.removedvideos != nil {
		edges = append(edges, post.EdgeVideos)
	}
	if m.removedattachments != nil {
		edges = append(edges, post.EdgeAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeAuthor:
		ids := make([]ent.Value, 0, len(m.removedauthor))
		for id := range m.removedauthor {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeVideos:
		ids := make([]ent.Value, 0, len(m.removedvideos))
		for id := range m.removedvideos {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedauthor {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.clearedcategory {
		edges = append(edges, post.EdgeCategory)
	}
	if m.clearedthumbnail {
		edges = append(edges, post.EdgeThumbnail)
	}
	if m.clearedimages {
		edges = append(edges, post.EdgeImages)
	}
	if m.clearedvideos {
		edges = append(edges, post.EdgeVideos)
	}
	if m.clearedattachments {
		edges = append(edges, post.EdgeAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeAuthor:
		return m.clearedauthor
	case post.EdgeCategory:
		return m.clearedcategory
	case post.EdgeThumbnail:
		return m.clearedthumbnail
	case post.EdgeImages:
		return m.clearedimages
	case post.EdgeVideos:
		return m.clearedvideos
	case post.EdgeAttachments:
		return m.clearedattachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeCategory:
		m.ClearCategory()
		return nil
	case post.EdgeThumbnail:
		m.ClearThumbnail()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case post.EdgeCategory:
		m.ResetCategory()
		return nil
	case post.EdgeThumbnail:
		m.ResetThumbnail()
		return nil
	case post.EdgeImages:
		m.ResetImages()
		return nil
	case post.EdgeVideos:
		m.ResetVideos()
		return nil
	case post.EdgeAttachments:
		m.ResetAttachments()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// PostAttachmentMutation represents an operation that mutates the PostAttachment nodes in the graph.
type PostAttachmentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *string
	size          *uint64
	addsize       *uint64
	name          *string
	mime          *string
	url           *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	post          *int
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*PostAttachment, error)
	predicates    []predicate.PostAttachment
}

var _ ent.Mutation = (*PostAttachmentMutation)(nil)

// postattachmentOption allows management of the mutation configuration using functional options.
type postattachmentOption func(*PostAttachmentMutation)

// newPostAttachmentMutation creates new mutation for the PostAttachment entity.
func newPostAttachmentMutation(c config, op Op, opts ...postattachmentOption) *PostAttachmentMutation {
	m := &PostAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypePostAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostAttachmentID sets the ID field of the mutation.
func withPostAttachmentID(id int) postattachmentOption {
	return func(m *PostAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *PostAttachment
		)
		m.oldValue = func(ctx context.Context) (*PostAttachment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostAttachment sets the old PostAttachment of the mutation.
func withPostAttachment(node *PostAttachment) postattachmentOption {
	return func(m *PostAttachmentMutation) {
		m.oldValue = func(context.Context) (*PostAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PostAttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *PostAttachmentMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *PostAttachmentMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the PostAttachment entity.
// If the PostAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostAttachmentMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *PostAttachmentMutation) ResetUUID() {
	m.uuid = nil
}

// SetSize sets the "size" field.
func (m *PostAttachmentMutation) SetSize(u uint64) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *PostAttachmentMutation) Size() (r uint64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the PostAttachment entity.
// If the PostAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostAttachmentMutation) OldSize(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *PostAttachmentMutation) AddSize(u uint64) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *PostAttachmentMutation) AddedSize() (r uint64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *PostAttachmentMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetName sets the "name" field.
func (m *PostAttachmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostAttachmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostAttachment entity.
// If the PostAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostAttachmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PostAttachmentMutation) ResetName() {
	m.name = nil
}

// SetMime sets the "mime" field.
func (m *PostAttachmentMutation) SetMime(s string) {
	m.mime = &s
}

// Mime returns the value of the "mime" field in the mutation.
func (m *PostAttachmentMutation) Mime() (r string, exists bool) {
	v := m.mime
	if v == nil {
		return
	}
	return *v, true
}

// OldMime returns the old "mime" field's value of the PostAttachment entity.
// If the PostAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostAttachmentMutation) OldMime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMime: %w", err)
	}
	return oldValue.Mime, nil
}

// ResetMime resets all changes to the "mime" field.
func (m *PostAttachmentMutation) ResetMime() {
	m.mime = nil
}

// SetURL sets the "url" field.
func (m *PostAttachmentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PostAttachmentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the PostAttachment entity.
// If the PostAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostAttachmentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *PostAttachmentMutation) ResetURL() {
	m.url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostAttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostAttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostAttachment entity.
// If the PostAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostAttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostAttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *PostAttachmentMutation) SetPostID(id int) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *PostAttachmentMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared returns if the "post" edge to the Post entity was cleared.
func (m *PostAttachmentMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *PostAttachmentMutation) PostID() (id int, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *PostAttachmentMutation) PostIDs() (ids []int) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *PostAttachmentMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Op returns the operation name.
func (m *PostAttachmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PostAttachment).
func (m *PostAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, postattachment.FieldUUID)
	}
	if m.size != nil {
		fields = append(fields, postattachment.FieldSize)
	}
	if m.name != nil {
		fields = append(fields, postattachment.FieldName)
	}
	if m.mime != nil {
		fields = append(fields, postattachment.FieldMime)
	}
	if m.url != nil {
		fields = append(fields, postattachment.FieldURL)
	}
	if m.created_at != nil {
		fields = append(fields, postattachment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postattachment.FieldUUID:
		return m.UUID()
	case postattachment.FieldSize:
		return m.Size()
	case postattachment.FieldName:
		return m.Name()
	case postattachment.FieldMime:
		return m.Mime()
	case postattachment.FieldURL:
		return m.URL()
	case postattachment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postattachment.FieldUUID:
		return m.OldUUID(ctx)
	case postattachment.FieldSize:
		return m.OldSize(ctx)
	case postattachment.FieldName:
		return m.OldName(ctx)
	case postattachment.FieldMime:
		return m.OldMime(ctx)
	case postattachment.FieldURL:
		return m.OldURL(ctx)
	case postattachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PostAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postattachment.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case postattachment.FieldSize:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case postattachment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case postattachment.FieldMime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMime(v)
		return nil
	case postattachment.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case postattachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PostAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostAttachmentMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, postattachment.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case postattachment.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case postattachment.FieldSize:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown PostAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostAttachmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostAttachmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostAttachmentMutation) ResetField(name string) error {
	switch name {
	case postattachment.FieldUUID:
		m.ResetUUID()
		return nil
	case postattachment.FieldSize:
		m.ResetSize()
		return nil
	case postattachment.FieldName:
		m.ResetName()
		return nil
	case postattachment.FieldMime:
		m.ResetMime()
		return nil
	case postattachment.FieldURL:
		m.ResetURL()
		return nil
	case postattachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PostAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.post != nil {
		edges = append(edges, postattachment.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostAttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postattachment.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostAttachmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpost {
		edges = append(edges, postattachment.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostAttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case postattachment.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostAttachmentMutation) ClearEdge(name string) error {
	switch name {
	case postattachment.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown PostAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostAttachmentMutation) ResetEdge(name string) error {
	switch name {
	case postattachment.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown PostAttachment edge %s", name)
}

// PostImageMutation represents an operation that mutates the PostImage nodes in the graph.
type PostImageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *string
	width         *uint32
	addwidth      *uint32
	height        *uint32
	addheight     *uint32
	hash          *string
	title         *string
	url           *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	post          *int
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*PostImage, error)
	predicates    []predicate.PostImage
}

var _ ent.Mutation = (*PostImageMutation)(nil)

// postimageOption allows management of the mutation configuration using functional options.
type postimageOption func(*PostImageMutation)

// newPostImageMutation creates new mutation for the PostImage entity.
func newPostImageMutation(c config, op Op, opts ...postimageOption) *PostImageMutation {
	m := &PostImageMutation{
		config:        c,
		op:            op,
		typ:           TypePostImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostImageID sets the ID field of the mutation.
func withPostImageID(id int) postimageOption {
	return func(m *PostImageMutation) {
		var (
			err   error
			once  sync.Once
			value *PostImage
		)
		m.oldValue = func(ctx context.Context) (*PostImage, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostImage sets the old PostImage of the mutation.
func withPostImage(node *PostImage) postimageOption {
	return func(m *PostImageMutation) {
		m.oldValue = func(context.Context) (*PostImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PostImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *PostImageMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *PostImageMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the PostImage entity.
// If the PostImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostImageMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *PostImageMutation) ResetUUID() {
	m.uuid = nil
}

// SetWidth sets the "width" field.
func (m *PostImageMutation) SetWidth(u uint32) {
	m.width = &u
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *PostImageMutation) Width() (r uint32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the PostImage entity.
// If the PostImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostImageMutation) OldWidth(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds u to the "width" field.
func (m *PostImageMutation) AddWidth(u uint32) {
	if m.addwidth != nil {
		*m.addwidth += u
	} else {
		m.addwidth = &u
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *PostImageMutation) AddedWidth() (r uint32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *PostImageMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *PostImageMutation) SetHeight(u uint32) {
	m.height = &u
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *PostImageMutation) Height() (r uint32, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the PostImage entity.
// If the PostImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostImageMutation) OldHeight(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds u to the "height" field.
func (m *PostImageMutation) AddHeight(u uint32) {
	if m.addheight != nil {
		*m.addheight += u
	} else {
		m.addheight = &u
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *PostImageMutation) AddedHeight() (r uint32, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *PostImageMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetHash sets the "hash" field.
func (m *PostImageMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PostImageMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the PostImage entity.
// If the PostImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostImageMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PostImageMutation) ResetHash() {
	m.hash = nil
}

// SetTitle sets the "title" field.
func (m *PostImageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostImageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PostImage entity.
// If the PostImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostImageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostImageMutation) ResetTitle() {
	m.title = nil
}

// SetURL sets the "url" field.
func (m *PostImageMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PostImageMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the PostImage entity.
// If the PostImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostImageMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *PostImageMutation) ResetURL() {
	m.url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostImage entity.
// If the PostImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *PostImageMutation) SetPostID(id int) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *PostImageMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared returns if the "post" edge to the Post entity was cleared.
func (m *PostImageMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *PostImageMutation) PostID() (id int, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *PostImageMutation) PostIDs() (ids []int) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *PostImageMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Op returns the operation name.
func (m *PostImageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PostImage).
func (m *PostImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostImageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, postimage.FieldUUID)
	}
	if m.width != nil {
		fields = append(fields, postimage.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, postimage.FieldHeight)
	}
	if m.hash != nil {
		fields = append(fields, postimage.FieldHash)
	}
	if m.title != nil {
		fields = append(fields, postimage.FieldTitle)
	}
	if m.url != nil {
		fields = append(fields, postimage.FieldURL)
	}
	if m.created_at != nil {
		fields = append(fields, postimage.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postimage.FieldUUID:
		return m.UUID()
	case postimage.FieldWidth:
		return m.Width()
	case postimage.FieldHeight:
		return m.Height()
	case postimage.FieldHash:
		return m.Hash()
	case postimage.FieldTitle:
		return m.Title()
	case postimage.FieldURL:
		return m.URL()
	case postimage.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postimage.FieldUUID:
		return m.OldUUID(ctx)
	case postimage.FieldWidth:
		return m.OldWidth(ctx)
	case postimage.FieldHeight:
		return m.OldHeight(ctx)
	case postimage.FieldHash:
		return m.OldHash(ctx)
	case postimage.FieldTitle:
		return m.OldTitle(ctx)
	case postimage.FieldURL:
		return m.OldURL(ctx)
	case postimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PostImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postimage.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case postimage.FieldWidth:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case postimage.FieldHeight:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case postimage.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case postimage.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case postimage.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case postimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PostImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostImageMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, postimage.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, postimage.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case postimage.FieldWidth:
		return m.AddedWidth()
	case postimage.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case postimage.FieldWidth:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case postimage.FieldHeight:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown PostImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostImageMutation) ResetField(name string) error {
	switch name {
	case postimage.FieldUUID:
		m.ResetUUID()
		return nil
	case postimage.FieldWidth:
		m.ResetWidth()
		return nil
	case postimage.FieldHeight:
		m.ResetHeight()
		return nil
	case postimage.FieldHash:
		m.ResetHash()
		return nil
	case postimage.FieldTitle:
		m.ResetTitle()
		return nil
	case postimage.FieldURL:
		m.ResetURL()
		return nil
	case postimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PostImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.post != nil {
		edges = append(edges, postimage.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postimage.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpost {
		edges = append(edges, postimage.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostImageMutation) EdgeCleared(name string) bool {
	switch name {
	case postimage.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostImageMutation) ClearEdge(name string) error {
	switch name {
	case postimage.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown PostImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostImageMutation) ResetEdge(name string) error {
	switch name {
	case postimage.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown PostImage edge %s", name)
}

// PostThumbnailMutation represents an operation that mutates the PostThumbnail nodes in the graph.
type PostThumbnailMutation struct {
	config
	op            Op
	typ           string
	id            *int
	width         *uint32
	addwidth      *uint32
	height        *uint32
	addheight     *uint32
	hash          *string
	url           *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	post          *int
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*PostThumbnail, error)
	predicates    []predicate.PostThumbnail
}

var _ ent.Mutation = (*PostThumbnailMutation)(nil)

// postthumbnailOption allows management of the mutation configuration using functional options.
type postthumbnailOption func(*PostThumbnailMutation)

// newPostThumbnailMutation creates new mutation for the PostThumbnail entity.
func newPostThumbnailMutation(c config, op Op, opts ...postthumbnailOption) *PostThumbnailMutation {
	m := &PostThumbnailMutation{
		config:        c,
		op:            op,
		typ:           TypePostThumbnail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostThumbnailID sets the ID field of the mutation.
func withPostThumbnailID(id int) postthumbnailOption {
	return func(m *PostThumbnailMutation) {
		var (
			err   error
			once  sync.Once
			value *PostThumbnail
		)
		m.oldValue = func(ctx context.Context) (*PostThumbnail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostThumbnail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostThumbnail sets the old PostThumbnail of the mutation.
func withPostThumbnail(node *PostThumbnail) postthumbnailOption {
	return func(m *PostThumbnailMutation) {
		m.oldValue = func(context.Context) (*PostThumbnail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostThumbnailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostThumbnailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PostThumbnailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWidth sets the "width" field.
func (m *PostThumbnailMutation) SetWidth(u uint32) {
	m.width = &u
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *PostThumbnailMutation) Width() (r uint32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the PostThumbnail entity.
// If the PostThumbnail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostThumbnailMutation) OldWidth(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds u to the "width" field.
func (m *PostThumbnailMutation) AddWidth(u uint32) {
	if m.addwidth != nil {
		*m.addwidth += u
	} else {
		m.addwidth = &u
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *PostThumbnailMutation) AddedWidth() (r uint32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *PostThumbnailMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *PostThumbnailMutation) SetHeight(u uint32) {
	m.height = &u
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *PostThumbnailMutation) Height() (r uint32, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the PostThumbnail entity.
// If the PostThumbnail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostThumbnailMutation) OldHeight(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds u to the "height" field.
func (m *PostThumbnailMutation) AddHeight(u uint32) {
	if m.addheight != nil {
		*m.addheight += u
	} else {
		m.addheight = &u
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *PostThumbnailMutation) AddedHeight() (r uint32, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *PostThumbnailMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetHash sets the "hash" field.
func (m *PostThumbnailMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PostThumbnailMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the PostThumbnail entity.
// If the PostThumbnail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostThumbnailMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PostThumbnailMutation) ResetHash() {
	m.hash = nil
}

// SetURL sets the "url" field.
func (m *PostThumbnailMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PostThumbnailMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the PostThumbnail entity.
// If the PostThumbnail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostThumbnailMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *PostThumbnailMutation) ResetURL() {
	m.url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostThumbnailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostThumbnailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostThumbnail entity.
// If the PostThumbnail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostThumbnailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostThumbnailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *PostThumbnailMutation) SetPostID(id int) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *PostThumbnailMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared returns if the "post" edge to the Post entity was cleared.
func (m *PostThumbnailMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *PostThumbnailMutation) PostID() (id int, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *PostThumbnailMutation) PostIDs() (ids []int) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *PostThumbnailMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Op returns the operation name.
func (m *PostThumbnailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PostThumbnail).
func (m *PostThumbnailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostThumbnailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.width != nil {
		fields = append(fields, postthumbnail.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, postthumbnail.FieldHeight)
	}
	if m.hash != nil {
		fields = append(fields, postthumbnail.FieldHash)
	}
	if m.url != nil {
		fields = append(fields, postthumbnail.FieldURL)
	}
	if m.created_at != nil {
		fields = append(fields, postthumbnail.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostThumbnailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postthumbnail.FieldWidth:
		return m.Width()
	case postthumbnail.FieldHeight:
		return m.Height()
	case postthumbnail.FieldHash:
		return m.Hash()
	case postthumbnail.FieldURL:
		return m.URL()
	case postthumbnail.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostThumbnailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postthumbnail.FieldWidth:
		return m.OldWidth(ctx)
	case postthumbnail.FieldHeight:
		return m.OldHeight(ctx)
	case postthumbnail.FieldHash:
		return m.OldHash(ctx)
	case postthumbnail.FieldURL:
		return m.OldURL(ctx)
	case postthumbnail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PostThumbnail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostThumbnailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postthumbnail.FieldWidth:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case postthumbnail.FieldHeight:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case postthumbnail.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case postthumbnail.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case postthumbnail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PostThumbnail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostThumbnailMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, postthumbnail.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, postthumbnail.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostThumbnailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case postthumbnail.FieldWidth:
		return m.AddedWidth()
	case postthumbnail.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostThumbnailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case postthumbnail.FieldWidth:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case postthumbnail.FieldHeight:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown PostThumbnail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostThumbnailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostThumbnailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostThumbnailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostThumbnail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostThumbnailMutation) ResetField(name string) error {
	switch name {
	case postthumbnail.FieldWidth:
		m.ResetWidth()
		return nil
	case postthumbnail.FieldHeight:
		m.ResetHeight()
		return nil
	case postthumbnail.FieldHash:
		m.ResetHash()
		return nil
	case postthumbnail.FieldURL:
		m.ResetURL()
		return nil
	case postthumbnail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PostThumbnail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostThumbnailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.post != nil {
		edges = append(edges, postthumbnail.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostThumbnailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postthumbnail.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostThumbnailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostThumbnailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostThumbnailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpost {
		edges = append(edges, postthumbnail.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostThumbnailMutation) EdgeCleared(name string) bool {
	switch name {
	case postthumbnail.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostThumbnailMutation) ClearEdge(name string) error {
	switch name {
	case postthumbnail.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown PostThumbnail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostThumbnailMutation) ResetEdge(name string) error {
	switch name {
	case postthumbnail.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown PostThumbnail edge %s", name)
}

// PostVideoMutation represents an operation that mutates the PostVideo nodes in the graph.
type PostVideoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *string
	title         *string
	url           *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	post          *int
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*PostVideo, error)
	predicates    []predicate.PostVideo
}

var _ ent.Mutation = (*PostVideoMutation)(nil)

// postvideoOption allows management of the mutation configuration using functional options.
type postvideoOption func(*PostVideoMutation)

// newPostVideoMutation creates new mutation for the PostVideo entity.
func newPostVideoMutation(c config, op Op, opts ...postvideoOption) *PostVideoMutation {
	m := &PostVideoMutation{
		config:        c,
		op:            op,
		typ:           TypePostVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostVideoID sets the ID field of the mutation.
func withPostVideoID(id int) postvideoOption {
	return func(m *PostVideoMutation) {
		var (
			err   error
			once  sync.Once
			value *PostVideo
		)
		m.oldValue = func(ctx context.Context) (*PostVideo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostVideo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostVideo sets the old PostVideo of the mutation.
func withPostVideo(node *PostVideo) postvideoOption {
	return func(m *PostVideoMutation) {
		m.oldValue = func(context.Context) (*PostVideo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostVideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostVideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PostVideoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *PostVideoMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *PostVideoMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the PostVideo entity.
// If the PostVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostVideoMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *PostVideoMutation) ResetUUID() {
	m.uuid = nil
}

// SetTitle sets the "title" field.
func (m *PostVideoMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostVideoMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PostVideo entity.
// If the PostVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostVideoMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostVideoMutation) ResetTitle() {
	m.title = nil
}

// SetURL sets the "url" field.
func (m *PostVideoMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PostVideoMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the PostVideo entity.
// If the PostVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostVideoMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *PostVideoMutation) ResetURL() {
	m.url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostVideoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostVideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostVideo entity.
// If the PostVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostVideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostVideoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *PostVideoMutation) SetPostID(id int) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *PostVideoMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared returns if the "post" edge to the Post entity was cleared.
func (m *PostVideoMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *PostVideoMutation) PostID() (id int, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *PostVideoMutation) PostIDs() (ids []int) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *PostVideoMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Op returns the operation name.
func (m *PostVideoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PostVideo).
func (m *PostVideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostVideoMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.uuid != nil {
		fields = append(fields, postvideo.FieldUUID)
	}
	if m.title != nil {
		fields = append(fields, postvideo.FieldTitle)
	}
	if m.url != nil {
		fields = append(fields, postvideo.FieldURL)
	}
	if m.created_at != nil {
		fields = append(fields, postvideo.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostVideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postvideo.FieldUUID:
		return m.UUID()
	case postvideo.FieldTitle:
		return m.Title()
	case postvideo.FieldURL:
		return m.URL()
	case postvideo.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostVideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postvideo.FieldUUID:
		return m.OldUUID(ctx)
	case postvideo.FieldTitle:
		return m.OldTitle(ctx)
	case postvideo.FieldURL:
		return m.OldURL(ctx)
	case postvideo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PostVideo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostVideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postvideo.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case postvideo.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case postvideo.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case postvideo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PostVideo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostVideoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostVideoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostVideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PostVideo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostVideoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostVideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostVideoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostVideo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostVideoMutation) ResetField(name string) error {
	switch name {
	case postvideo.FieldUUID:
		m.ResetUUID()
		return nil
	case postvideo.FieldTitle:
		m.ResetTitle()
		return nil
	case postvideo.FieldURL:
		m.ResetURL()
		return nil
	case postvideo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PostVideo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostVideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.post != nil {
		edges = append(edges, postvideo.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostVideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postvideo.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostVideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostVideoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostVideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpost {
		edges = append(edges, postvideo.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostVideoMutation) EdgeCleared(name string) bool {
	switch name {
	case postvideo.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostVideoMutation) ClearEdge(name string) error {
	switch name {
	case postvideo.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown PostVideo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostVideoMutation) ResetEdge(name string) error {
	switch name {
	case postvideo.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown PostVideo edge %s", name)
}
